###执行器（Executor）
执行器Executor：
>用来管理Thread对象，Executor在客户端和任务执行之间提供一个间接层，和直接调用Thread的start方法不同，Executor会执行所有的任务

>通过Executors的静态方法创建ExecutorServices，然后管理所有任务，并为其创建执行线程，通常是创建单个Excutor然后管理所有的任务 \
shutdown方法的调用为了防止新任务被提交给这个Executor，当前线程会继续运行shutdown被调用之前提交的所有任务

###线程池：
> 对线程池的理解：\
          如果我们每使用一个线程就新建一个线程，使用方便但有问题，如果并发的线程数量很多，且执行很短时间就结束了，这样的话频繁创建和销毁线程会降低系统效率 \
          线程池是的存在就是为了：\
                使线程可以复用，执行完一个任务，不被销毁，转而执行另一个任务，提高复用性

> 创建线程是有开销的，所以一旦创建了线程，能复用就复用，实在不行再新建

   
####然后注意**任务** 和 **线程**的区别：
        任务被提交给线程，线程执行完，然后可以执行另一个任务，所以才会用现场复用的概念


###线程池的类型
    1、CachedThreadPool
        缓存型线程池，首先查看池中有没有以前建立的线程，如果有就reuse，如果没有就新建一个加入到池子
        通常用于生存期很短的异步型任务
        线程有存活时间，如果超过了，就会被移除，默认timeout是60s，注意这个时间是执行完任务后，如果60s内，线程没有被使用，就会被移除并回收
    2、FixedThreadPool
        和cachedThreadPool差不多，如果有就reuse，但不能随时新建，因为它有容量限制
        任意时间点，都最多有固定数目的活动线程，如果需要新建线程，只能放到队列排队，等待池中有线程被中止然后回收
        也就是说，一次性预先执行代价高昂的线程分配，然后从线程池拿线程执行任务，如果任务多于线程数目，就会被挂到队列里等待

     3、SingleThreadExecutor
        线程数目限制为1 的fixedThreadPool，单例线程
        线程连续运行，一次只能运行一个任务，如果提交多个任务，会排队
        SingleThreadExecutor会序列化所有提交给它的任务，并维护自己的悬挂任务队列
        例如监听进入套接字连接的任务

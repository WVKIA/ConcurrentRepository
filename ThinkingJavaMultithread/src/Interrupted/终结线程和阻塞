终结任务：
    要中止任务，首先需要了解线程有哪几种状态

    1、新建（new）
            当线程被创建，已经分配了资源，并且初始化，但尚未启动，需要调度器将其调度
     2、就绪（runnable）
            runnable包括了操作系统线程状态中的running和ready，可能运行也可能等待CPU分配时间
     3、阻塞（blocked）
            线程正在等待获取一个排他锁，这个锁将在另一个线程放弃时。
     4、Java线程 等待（wait）
          Java线程状态
            1、无限期等待
                CPU不会分配时间，它们要等待被其他线程显示唤醒，以下方法：
                    · 没有设置Timeout参数的 Object.wait()方法
                    ·没有设置Timeout参数的 Thread.join()方法
                    ·LockSupport.park(）方法
            2、限期等待
                CPU也不会分配时间，但它们无需其他线程唤醒，一定时间后它们会由系统自动唤醒，进入就绪状态
                    ·Thread.sleep()
                    ·设置Timeout的Object.wait()
                    ·设置Timeout的Thread.join()
                    ·LockSupport.parkNanos()
                    ·LockSupport.parkUntil()
     5、结束，死亡（Terminated）
            终止线程的线程状态，结束执行



下面我们看一下 中断（Java的中断）
    当一个线程正在处于阻塞状态时，需要终止它，不能在代码中等待某一个状态点然后查看值，因为它有可能一直阻塞，需要强制这个任务跳出阻塞状态

中断（Interrupt）
    中断在Runnable.run方法中间打断被阻塞的任务，可能需要清理资源，更像是异常，所以Java线程中使用异常中断，意味着需要使用异常处理来控制流程，为了以异常的方式终止线程，需要考虑代码执行路径，并编写
   catch子句用来正确清除所有的事物，例如资源



   Thread的类有个  interrupt（） 方法，可以用来终结被阻塞的任务，这个方法会设置 线程的中断状态true，表示该线程处于可以被中断的状态，这时候，如果这个线程已经被阻塞了，或者
   试图执行一个阻塞操作，那么这个线程将会抛出InterruptedException，当抛出这个异常时就表示退出了阻塞状态，需要我们处理资源的清理
   当这个异常抛出来的时候，或者该线程自己调用了Thread.interrupted（）方法，中断状态会被复位为false，表示又可以阻塞而不被中断



   为了调用 interrupted（），必须首先持有这个Thread对象，新的concurrent类库希望避免对Thread对象的直接操作，尽量通过Executor来操作，
   如果在Executor上调用 shutdownNow（），那么它会发送一个 interrupt（）调用给它启动的所有线程，用来关闭Executor调用的所有任务，
   但如果只希望中断某一个单一任务，使用Executor的话就需要通过调用submit（）而不是executor（）来启动任务，就可以持有该任务的上下文，
        submit（）返回一个泛型Future<?>，持有这个Future的关键在于可以在它上面调用cancel（），并因此中断某个特定任务，传true的话就可以终止这个任务



*我们通过Interrupting的测试类可以看出：
    能够中断 对 sleep（）的调用，但不能中断 IO的阻塞、和Synchronized方法的阻塞
    特别注意在创建执行 I/O的任务时，如果IO锁住，那么对于多线程是危害很大的

    通常NIO提供更好的I/O中断



可以看到，就像前面不可中断的IO阻塞一样，只有任务以不可中断的方式被阻塞，那么都会有锁住程序的可能，为了防止这个情况的发生，concurrent包中提供了 ReentrantLock，在ReentrantLock阻塞的
任务可以被中断，同时这个也是类似synchronized的可重入的互斥锁，但可以被中断这个特性和sychronized就不一样
ReentrantLock可以打断互斥造成的阻塞，但interrupt方法不能打断由synchronized造成的互斥阻塞


* 检查中断：
    注意，当你在线程上调用interrupt（）时，中断发生的唯一时刻是在任务要进入阻塞操作中，或者已经在阻塞操作中。但如果只是通过阻塞调用抛出异常然后才能退出线程任务，肯定是不行的。
    所以要有两步处理。一个是当发生阻塞了，调用interrupt（）抛出异常，退出任务，另一个是没有阻塞发生，也需要一个步骤来退出任务，正确清理资源。

    这个机会由中断状态来提供，状态为true可以通过调用interrupt（）方法，就像前面说的，表示可以接收中断，还可以通过 调用 interrupted（）方法来检查中断状态，不仅可以告诉我们interrupt（）方法是否被调用
    过，还可以清除中断状态，也就是可以告诉我们interrupt（）方法有没有被调用，有没有线程发出中断信号，如果有，即中断标志设为了true，这时候 interrupted（）方法返回true，表示中断标志被设置，同时
    还会把这个状态清除掉，设为false

    即如果两次调用 interrupted（），第一次会返回true，然后把中断标志置为false，第二次就会返回false，因为中断标志为false

    特别注意 interrupted（）的含义，表示“测试当前线程是否已经中断，当前线程是指运行 this.interrupted()方法的线程”
        例如
            psvm{
                thread=new Thread()
                thread.start()
                thread.interrupt()

                thread.interrupted()
                thread.interrupted()

            }
         注意，此时会返回两次 false
        其原因在于  定义中的当前线程 ，interrupted（）方法调用的当前线程是 main线程，main线程没有被interrupt（），所以都是false，所以 interrupted（）通常都是作用在runnable方法表示当前任务的


        interrupted(）的意义在于通过检查当前线程是否处于被中断状态，然后处理退出程序
        所以我们通常的是，两个结合在一起，抛出异常和中断检查 同时来处理中断



        try{

            //中断检测
            while(!Thread.interrupted()){
                //可能的阻塞操作
            }
        }catch(IterruptedException e){
            //中断抛出异常

        }



* 注意代码 InterruptingIdiom的解释 *
    如果 中断 interrupt（）的调用发出在代码点point1 时到达，在经过sleep（）的时候阻塞会抛出异常，然后退出，清理掉之前创建的 n1 对象，
    经由外部 catch 子句捕获，退出程序
    如果在 代码点point2的时候到达，首先循环会结束，然后所有对象清理，最后由while（）判断退出。

    如果没有 Thread.interrupted(）的判断，而是改为 while（true），那么这个中断就会被忽略，继续执行

    InterruptingIdiom代码是个很好的处理模板

    所以我们在设计相应interrupt（）的类时，必须确保它的一致性，也就是所有需要清理的对象后面都需要跟着
    try - finally子句用来清理，使无论run如何退出，都能保持清理的完成


如果while判断场景适应于只要线程未被中断，就会一直持续下去，并不是一次性执行完成的
既然调用了interrupted（）方法来判断了，说明打算响应中断，如果已经中断，被响应了，就没有保留中断状态的必要，中断标志会被置为false

interrupted（）的存在是说明你知道了中断的存在并且打算响应它


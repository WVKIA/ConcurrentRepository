###共享资源竞争

>多线程要解决的问题就是：\
>    对于并发工作，需要采用某种方式防止两个任务同时访问一个资源，至少关键阶段不能发生这种情况

####防止资源冲突的方法

#####1. 当资源被一个任务使用时，对其加锁，其他任务必须等待被解锁之后，才能操作资源
+ Java提供的关键字就是 synchronized \
>Java中共享资源一般以对象的形式存在，所有的对象都自动有一个单一的锁，也称作“监视器”。当在这个对象上任意调用 synchronized 方法，此对象都会被加锁，这时其他的synchronized方法必须等待前一个方法结束，锁释放，之后，才能获取锁然后执行

>一个任务可以多次获得对象的锁，如果一个方法在同一个对象上调用了另一个，就会发生这样的情况。JVM会跟踪对象的锁，然后计数，每方法执行完释放锁后就 减一，直到为 0  释放对象锁，其他任务才可以使用此资源

>对于每个类，也有一个锁，作为类Class对象的一部分，所以 synchronized static 方法可以在类范围内防止 static 数据的并发访问

>同步规则：
>    1. 同步一个变量，读写线程都必须使用相同的监视器锁同步 
>    2. 如果一个方法处理临界数据，那么所有涉及该数据的方法都必须被同步


基本上所有并发模式在解决线程冲突问题都采用**序列化访问共享资源**，也就是给定时刻只允许一个任务访问共享资源。通常是在代码前加一个锁语句，锁语句产生一种互斥的效果，这种机制也叫互斥量mutext。

+  Concurrent类库提供了显示互斥机制：Lock对象 \
    Lock对象必须被显示的创建、锁定和释放

#####2. 而防止资源冲突的第二种方法就是：为每一个线程做一个单独的备份，使资源和线程关联起来，Java常用ThreadLocal类来实现
> ThreadLocal只有一个对象，但每个线程都会为其做一个单独备份，防止冲突，
    只能用get() 和 set() 方法访问对象的内容 \
 > ThreadLocal可以保证不会出现竞争条件，因为每个线程不会冲突
 
 
 我们需要对共享变量进行锁定，以防止多个线程同时访问共享资源导致出现数据错误，例如多个任务访问同一个账户，所以在java中内建了sychronized关键字，用来保护操作资源的代码片段，而sychronized操作的是所有java对象
 都含有的单一的锁（监视器），sychronized static可以用来锁定类范围下static数据的并发访问
 
 如果类中存在一个共享变量，每个访问临界共享资源的方法都必须被同步
 
 -->  concurrent类库的Lock对象可以用来替代sychronized关键字，显式的Lock对象在加锁和释放锁方面，相对于内建的sychronized锁，有着更细粒度的控制。
 
 --> 对于像 i++的操作，因为非原子性，会导致i多线程方面数据错误，出现中间状态的数据，所以引出了原子类，也就是保证基本类型操作的原子性，而不必使用sychronized来锁定资源
 
 
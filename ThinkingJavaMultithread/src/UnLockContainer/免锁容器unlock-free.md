##免锁容器
>容器是编程中的基础工具，也包括并发编程，早期的Java为了同步容器，有像Vector和Hashtable这样的，但都是通过synchronized方法进行同步，有很大的性能消耗
 在Java1.2之后，**提供了Collections的static同步方法**，从而同步不同类型的容器。但这种开销依然是通过synchronized加锁机制。

>Java5提供了新的多线程容器，通过更灵巧的方式消除加锁，不仅实现多线程并发，也提高了线程安全的性能。
 
 >免锁容器的通用策略都是：对容器的修改可以和读取操作同时发生，只有读取者只能看到完成修改的结果即可。
 修改是在容器数据结构的某个部分的一个单独副本上执行的，并且这个副本在修改过程中不可视，只有当修改完成时，被修改的结构才会自动与主数据进行交换，之后读取者就可以看到这个修改了

例如CopyOnWriteArrayList中，写入导致整个底层数组被复制一个副本，而源数组保留在原地，这样复制的数组被修改，读取操作在源数组。当修改完成，通过一个原子性操作，将新的数组换入，使得新的
读取操作可以看到新的修改。 当多个线程遍历数组并写入时，不会导致ConcurrentModificationExcetion。

CopyOnWriteArraySet使用CopyOnWriteArraylist实现
ConcurrentHashmap和ConcurrentLinkedQueue使用类似的技术，允许并发的读取和写入，但容器中只有部分内容而不是整个容器被复制。

乐观锁

在原子对象中Atomic对象执行原子操作时，并没有使用互斥，当我们需要更新一个Atomic对象值，需要使用一个compareAndSet的方法，将新值和旧值一起提交，如果旧值和之前不一致，那么这个操作就是失败的--
意味着有别的操作已经在此之前修改了这个对象。而我们平常使用互斥来防止多个任务同时访问一个对象，但这里我们是乐观的，保持数据未锁定，并希望没有任何其他任务修改了它，从而获得性能的好处

但如果compareAndSet失败，我们就要作出自己的处理

1. 读写锁：
    readWriterLock
    * 读写锁使用场景：向数据结构相对不频繁的写入，但有多个任务经常读取这个数据结构。
    * ReadWriterLock使得可以同时有多个读取者，只要它们都不试图写入
    * 如果写锁已经被其他任务持有，那么不允许任何读取者访问，直到写锁释放
   